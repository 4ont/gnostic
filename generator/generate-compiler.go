// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"fmt"
	"sort"
	"strings"

	"github.com/googleapis/openapi-compiler/printer"
)

func (typeset *TypeCollection) generateCompiler(packageName string, license string) string {
	code := printer.Code{}
	code.Print(license)
	code.Print("// THIS FILE IS AUTOMATICALLY GENERATED.")
	code.Print()
	code.Print("package %s", packageName)
	code.Print()
	code.Print("import (")
	imports := []string{
		"fmt",
		"encoding/json",
		"github.com/googleapis/openapi-compiler/compiler",
	}
	for _, filename := range imports {
		code.Print("\"" + filename + "\"")
	}
	code.Print(")")
	code.Print()

	code.Print("func Version() string {")
	code.Print("  return \"%s\"", packageName)
	code.Print("}")
	code.Print()

	typeNames := typeset.sortedTypeNames()

	// constructors
	for _, typeName := range typeNames {
		code.Print("func New%s(in interface{}, context *compiler.Context) (*%s, error) {", typeName, typeName)
		code.Print("errors := make([]error, 0)")

		typeModel := typeset.TypeModels[typeName]
		parentTypeName := typeName

		if typeModel.IsStringArray {
			code.Print("value, ok := in.(string)")
			code.Print("x := &TypeItem{}")
			code.Print("if ok {")
			code.Print("x.Value = make([]string, 0)")
			code.Print("x.Value = append(x.Value, value)")
			code.Print("} else {")
			code.Print("errors = append(errors, compiler.NewError(context, fmt.Sprintf(\"unexpected value for string array: %%+v\", in)))")
			code.Print("}")
			code.Print("if len(errors) > 0 {")
			code.Print("  return x, compiler.NewErrorGroup(errors)")
			code.Print("} else {")
			code.Print("  return x, nil")
			code.Print("}")
			code.Print("}")
			code.Print()
			continue
		}

		if typeModel.IsItemArray {
			code.Print("m, ok := compiler.UnpackMap(in)")
			code.Print("if (!ok) {")
			code.Print("errors = append(errors, compiler.NewError(context, fmt.Sprintf(\"unexpected value for item array: %%+v\", in)))")
			code.Print("}")

			code.Print("x := &ItemsItem{}")
			code.Print("if ok {")
			code.Print("x.Schema = make([]*Schema, 0)")
			code.Print("y, err := NewSchema(m, compiler.NewContext(\"<array>\", context))")
			code.Print("if err != nil {")
			code.Print("return nil, err")
			code.Print("}")
			code.Print("x.Schema = append(x.Schema, y)")
			code.Print("} else {")
			code.Print("errors = append(errors, compiler.NewError(context, fmt.Sprintf(\"unexpected value for item array: %%+v\", in)))")
			code.Print("}")
			code.Print("if len(errors) > 0 {")
			code.Print("  return x, compiler.NewErrorGroup(errors)")
			code.Print("} else {")
			code.Print("  return x, nil")
			code.Print("}")
			code.Print("}")
			code.Print()
			continue
		}

		if typeModel.IsBlob {
			code.Print("x := &Any{}")
			code.Print("bytes, _ := json.Marshal(in)")
			code.Print("x.Value = string(bytes)")
			code.Print("if len(errors) > 0 {")
			code.Print("  return x, compiler.NewErrorGroup(errors)")
			code.Print("} else {")
			code.Print("  return x, nil")
			code.Print("}")
			code.Print("}")
			code.Print()
			continue
		}

		if typeModel.Name == "StringArray" {
			code.Print("a, ok := in.([]interface{})")
			code.Print("if ok {")
			code.Print("x := &StringArray{}")
			code.Print("x.Value = make([]string, 0)")
			code.Print("for _, s := range a {")
			code.Print("x.Value = append(x.Value, s.(string))")
			code.Print("}")
			code.Print("if len(errors) > 0 {")
			code.Print("  return x, compiler.NewErrorGroup(errors)")
			code.Print("} else {")
			code.Print("  return x, nil")
			code.Print("}")
			code.Print("} else {")
			code.Print("return nil, nil")
			code.Print("}")
			code.Print("}")
			code.Print()
			continue
		}
		code.Print("m, ok := compiler.UnpackMap(in)")
		code.Print("if (!ok) {")
		code.Print("errors = append(errors, compiler.NewError(context, fmt.Sprintf(\"unexpected value for %s section: %%+v\", in)))", typeName)
		code.Print("}")
		oneOfWrapper := typeModel.OneOfWrapper

		if len(typeModel.Required) > 0 {
			// verify that map includes all required keys
			keyString := ""
			sort.Strings(typeModel.Required)
			for _, k := range typeModel.Required {
				if keyString != "" {
					keyString += ","
				}
				keyString += "\""
				keyString += k
				keyString += "\""
			}
			code.Print("requiredKeys := []string{%s}", keyString)
			code.Print("if !compiler.MapContainsAllKeys(m, requiredKeys) {")
			code.Print("errors = append(errors, compiler.NewError(context, \"does not contain all required properties (%s)\"))",
				strings.Replace(keyString, "\"", "'", -1))
			code.Print("}")
		}

		if !typeModel.Open {
			// verify that map has no unspecified keys
			allowedKeys := make([]string, 0)
			for _, property := range typeModel.Properties {
				if !property.Implicit {
					allowedKeys = append(allowedKeys, property.Name)
				}
			}
			sort.Strings(allowedKeys)
			allowedKeyString := ""
			for _, allowedKey := range allowedKeys {
				if allowedKeyString != "" {
					allowedKeyString += ","
				}
				allowedKeyString += "\""
				allowedKeyString += allowedKey
				allowedKeyString += "\""
			}
			allowedPatternString := ""
			if typeModel.OpenPatterns != nil {
				for _, pattern := range typeModel.OpenPatterns {
					if allowedPatternString != "" {
						allowedPatternString += ","
					}
					allowedPatternString += "\""
					allowedPatternString += pattern
					allowedPatternString += "\""
				}
			}
			// verify that map includes only allowed keys and patterns
			code.Print("allowedKeys := []string{%s}", allowedKeyString)
			code.Print("allowedPatterns := []string{%s}", allowedPatternString)
			code.Print("if !compiler.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {")
			code.Print("errors = append(errors, compiler.NewError(context,\nfmt.Sprintf(\"includes properties not in (%s) or (%s): %%+v\",\ncompiler.SortedKeysForMap(m))))",
				strings.Replace(allowedKeyString, "\"", "'", -1),
				strings.Replace(allowedPatternString, "\"", "'", -1))
			code.Print("}")
		}

		code.Print("  x := &%s{}", typeName)

		var fieldNumber = 0
		for _, propertyModel := range typeModel.Properties {
			propertyName := propertyModel.Name
			fieldNumber += 1
			propertyType := propertyModel.Type
			if propertyType == "int" {
				propertyType = "int64"
			}
			var displayName = propertyName
			if displayName == "$ref" {
				displayName = "_ref"
			}
			if displayName == "$schema" {
				displayName = "_schema"
			}
			displayName = camelCaseToSnakeCase(displayName)

			var line = fmt.Sprintf("%s %s = %d;", propertyType, displayName, fieldNumber)
			if propertyModel.Repeated {
				line = "repeated " + line
			}
			code.Print("// " + line)

			fieldName := strings.Title(propertyName)
			if propertyName == "$ref" {
				fieldName = "XRef"
			}

			typeModel, typeFound := typeset.TypeModels[propertyType]
			if typeFound && !typeModel.IsPair {
				if propertyModel.Repeated {
					code.Print("v%d := compiler.MapValueForKey(m, \"%s\")", fieldNumber, propertyName)
					code.Print("if (v%d != nil) {", fieldNumber)
					code.Print("// repeated %s", typeModel.Name)
					code.Print("x.%s = make([]*%s, 0)", fieldName, typeModel.Name)
					code.Print("a, ok := v%d.([]interface{})", fieldNumber)
					code.Print("if ok {")
					code.Print("for _, item := range a {")
					code.Print("y, err := New%s(item, compiler.NewContext(\"%s\", context))", typeModel.Name, propertyName)
					code.Print("if err != nil {")
					code.Print("errors = append(errors, err)")
					code.Print("}")
					code.Print("x.%s = append(x.%s, y)", fieldName, fieldName)
					code.Print("}")
					code.Print("}")
					code.Print("}")
				} else {
					if oneOfWrapper {
						code.Print("{")
						code.Print("// errors are ok here, they mean we just don't have the right subtype")
						code.Print("t, errors := New%s(m, compiler.NewContext(\"%s\", context))", typeModel.Name, propertyName)
						code.Print("if errors == nil {")
						code.Print("x.Oneof = &%s_%s{%s: t}", parentTypeName, typeModel.Name, typeModel.Name)
						code.Print("}")
						code.Print("}")
					} else {
						code.Print("v%d := compiler.MapValueForKey(m, \"%s\")", fieldNumber, propertyName)
						code.Print("if (v%d != nil) {", fieldNumber)
						code.Print("var err error")
						code.Print("x.%s, err = New%s(v%d, compiler.NewContext(\"%s\", context))",
							fieldName, typeModel.Name, fieldNumber, propertyName)
						code.Print("if err != nil {")
						code.Print(" errors = append(errors, err)")
						code.Print("}")
						code.Print("}")
					}
				}
			} else if propertyType == "string" {
				if propertyModel.Repeated {
					code.Print("v%d := compiler.MapValueForKey(m, \"%s\")", fieldNumber, propertyName)
					code.Print("if (v%d != nil) {", fieldNumber)
					code.Print("v, ok := v%d.([]interface{})", fieldNumber)
					code.Print("if ok {")
					code.Print("x.%s = compiler.ConvertInterfaceArrayToStringArray(v)", fieldName)
					code.Print("} else {")
					code.Print(" errors = append(errors, compiler.NewError(context, fmt.Sprintf(\"unexpected value for %s property: %%+v\", in)))", propertyName)
					code.Print("}")
					code.Print("}")
				} else {
					code.Print("v%d := compiler.MapValueForKey(m, \"%s\")", fieldNumber, propertyName)
					code.Print("if (v%d != nil) {", fieldNumber)
					code.Print("x.%s, ok = v%d.(string)", fieldName, fieldNumber)
					code.Print("if !ok {errors = append(errors, compiler.NewError(context, fmt.Sprintf(\"unexpected value for %s. expected a string, got %%+v\", v%d)))}", propertyName, fieldNumber)
					code.Print("}")
				}
			} else if propertyType == "float" {
				code.Print("v%d := compiler.MapValueForKey(m, \"%s\")", fieldNumber, propertyName)
				code.Print("if (v%d != nil) {", fieldNumber)
				code.Print("x.%s = v%d.(float64)", fieldName, fieldNumber)
				code.Print("}")
			} else if propertyType == "int64" {
				code.Print("v%d := compiler.MapValueForKey(m, \"%s\")", fieldNumber, propertyName)
				code.Print("if (v%d != nil) {", fieldNumber)
				code.Print("x.%s = v%d.(int64)", fieldName, fieldNumber)
				code.Print("}")
			} else if propertyType == "bool" {
				code.Print("v%d := compiler.MapValueForKey(m, \"%s\")", fieldNumber, propertyName)
				code.Print("if (v%d != nil) {", fieldNumber)
				if oneOfWrapper {
					propertyName := "Boolean"
					code.Print("x.Oneof = &%s_%s{%s: v%d.(bool)}", parentTypeName, propertyName, propertyName, fieldNumber)
				} else {
					code.Print("x.%s = v%d.(bool)", fieldName, fieldNumber)
				}
				code.Print("}")
			} else {
				mapTypeName := propertyModel.MapType
				isMap := mapTypeName != ""
				if isMap {
					code.Print("// MAP: %s %s", mapTypeName, propertyModel.Pattern)
					if mapTypeName == "string" {
						code.Print("x.%s = make([]*NamedString, 0)", fieldName)
					} else {
						code.Print("x.%s = make([]*Named%s, 0)", fieldName, mapTypeName)
					}
					code.Print("for _, item := range m {")
					code.Print("k := item.Key.(string)")
					code.Print("v := item.Value")
					if propertyModel.Pattern != "" {
						code.Print("if compiler.PatternMatches(\"%s\", k) {", propertyModel.Pattern)
					}
					code.Print("pair := &Named" + strings.Title(mapTypeName) + "{}")
					code.Print("pair.Name = k")
					if mapTypeName == "string" {
						code.Print("pair.Value = v.(string)")
					} else {
						code.Print("var err error")
						code.Print("pair.Value, err = New%s(v, compiler.NewContext(k, context))", mapTypeName)
						code.Print("if err != nil {")
						code.Print("return nil, err")
						code.Print("}")
					}
					code.Print("x.%s = append(x.%s, pair)", fieldName, fieldName)
					if propertyModel.Pattern != "" {
						code.Print("}")
					}
					code.Print("}")
				} else {
					code.Print("// TODO: %s", propertyType)
				}
			}
		}
		code.Print("if len(errors) > 0 {")
		code.Print("  return x, compiler.NewErrorGroup(errors)")
		code.Print("} else {")
		code.Print("  return x, nil")
		code.Print("}")
		code.Print("}\n")
	}

	// ResolveReferences() methods
	for _, typeName := range typeNames {
		code.Print("func (m *%s) ResolveReferences(root string) (interface{}, error) {", typeName)
		//code.Print("  log.Printf(\"%s.ResolveReferences(%%+v)\", m)", typeName)

		typeModel := typeset.TypeModels[typeName]
		if typeModel.OneOfWrapper {
			// call ResolveReferences on whatever is in the Oneof.
			for _, propertyModel := range typeModel.Properties {
				propertyType := propertyModel.Type
				_, typeFound := typeset.TypeModels[propertyType]
				if typeFound {
					code.Print("{")
					code.Print("p, ok := m.Oneof.(*%s_%s)", typeName, propertyType)
					code.Print("if ok {")
					if propertyType == "JsonReference" { // Special case for OpenAPI
						code.Print("info, err := p.%s.ResolveReferences(root)", propertyType)
						code.Print("if err != nil {")
						code.Print("  return nil, err")
						code.Print("} else if info != nil {")
						code.Print("  n, err := New%s(info, nil)", typeName)
						code.Print("  if err != nil {")
						code.Print("    return nil, err")
						code.Print("  } else if n != nil {")
						code.Print("    *m = *n")
						code.Print("    return nil, nil")
						code.Print("  }")
						code.Print("}")
					} else {
						code.Print("p.%s.ResolveReferences(root)", propertyType)
					}
					code.Print("}")
					code.Print("}")
				}
			}
		} else {
			for _, propertyModel := range typeModel.Properties {
				propertyName := propertyModel.Name
				var displayName = propertyName
				if displayName == "$ref" {
					displayName = "_ref"
				}
				if displayName == "$schema" {
					displayName = "_schema"
				}
				displayName = camelCaseToSnakeCase(displayName)

				fieldName := strings.Title(propertyName)
				if propertyName == "$ref" {
					fieldName = "XRef"
					code.Print("if m.XRef != \"\" {")
					//code.Print("log.Printf(\"%s reference to resolve %%+v\", m.XRef)", typeName)
					code.Print("info := compiler.ReadInfoForRef(root, m.XRef)")
					//code.Print("log.Printf(\"%%+v\", info)")

					if len(typeModel.Properties) > 1 {
						code.Print("if info != nil {")
						code.Print("replacement, _ := New%s(info, nil)", typeName)
						code.Print("*m = *replacement")
						code.Print("return m.ResolveReferences(root)")
						code.Print("}")
					} else {
						code.Print("return info, nil")
					}

					code.Print("return info, nil")
					code.Print("}")
				}

				if !propertyModel.Repeated {
					propertyType := propertyModel.Type
					typeModel, typeFound := typeset.TypeModels[propertyType]
					if typeFound && !typeModel.IsPair {
						code.Print("if m.%s != nil {", fieldName)
						code.Print("m.%s.ResolveReferences(root)", fieldName)
						code.Print("}")
					}
				} else {
					propertyType := propertyModel.Type
					_, typeFound := typeset.TypeModels[propertyType]
					if typeFound {
						code.Print("for _, item := range m.%s {", fieldName)
						code.Print("if item != nil {")
						code.Print("item.ResolveReferences(root)")
						code.Print("}")
						code.Print("}")
					}

				}
			}
		}
		code.Print("  return nil, nil")
		code.Print("}\n")
	}

	return code.String()
}
