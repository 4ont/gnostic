// Client code 

import Foundation
import Dispatch

enum ClientError: Swift.Error {
  case errorWithCode(Int)
}

public class Client {
  var service : String
  
  public init(service: String) {
  	self.service = service
  }	
//-{% for serviceMethod in renderer.methods %}

  // {{ serviceMethod.description }}
  public func {{ serviceMethod.name }}({{ .|clientParametersDeclaration:serviceMethod }}) throws {{ .|clientReturnDeclaration:serviceMethod }} {
	  var path = self.service 
	  path = path + "{{ serviceMethod.path }}"
	  //-{% for serviceTypeField in serviceMethod|parametersTypeFields %}
	  //-{% if serviceTypeField.position == "path" %}
	  path = path.replacingOccurrences(of:"{"+"{{ serviceTypeField.name }}"+"}", with:"\({{ serviceTypeField.name }})")
	  //-{% endif %}
	  //-{% endfor %}
	  let url = URL(string:path)
	  var request = URLRequest(url:url!)
	  request.httpMethod = "{{ serviceMethod.method }}"
	  //-{% for serviceTypeField in serviceMethod|parametersTypeFields %}
	  //-{% if serviceTypeField.position == "body" %}
	  let jsonObject = {{ serviceTypeField.name }}.jsonObject()
	  request.httpBody = try JSONSerialization.data(withJSONObject:jsonObject)
	  //-{% endif %}
	  //-{% endfor %}
      //-{% if serviceMethod|hasResponses %}	  	  
	  let (data, response, error) = URLSession.shared.fetch(request)
	  //-{% else %}
	  let (_, response, error) = URLSession.shared.fetch(request)
	  //-{% endif %}
	  if error != nil {
	  	throw ClientError.errorWithCode(0)
	  }
	  let httpResponse = response as! HTTPURLResponse
	  if httpResponse.statusCode == 200 {
	    //-{% if serviceMethod|hasResponses %}	  
	    if let data = data {
	      let jsonObject = try JSONSerialization.jsonObject(with:data)
		  if let value = {{ serviceMethod.resultTypeName }}(jsonObject:jsonObject) {	      
		    return value
	  	  }
	    }
	    return {{ serviceMethod.resultTypeName }}()
	    //-{% endif %}
	  } else {
	  	throw ClientError.errorWithCode(httpResponse.statusCode)
	  }
  }
//-{% endfor %}
}

extension URLSession {
  func fetch(_ urlRequest: URLRequest) -> (Data?, URLResponse?, Error?) {
    var data: Data?
    var response: URLResponse?
    var error: Error?
    let sem = DispatchSemaphore(value: 0)
    let task = self.dataTask(with: urlRequest, completionHandler: {
      data = $0
      response = $1
      error = $2 as! Error?
      sem.signal()
    })
    task.resume()
    let result = sem.wait(timeout: DispatchTime.distantFuture)
    switch result {
    case .success:
      return (data, response, error)
    case .timedOut:
      return (data, response, nil)
    }
  }
}
