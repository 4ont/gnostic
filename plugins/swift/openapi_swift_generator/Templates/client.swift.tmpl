// Client code 

import Foundation
import Dispatch
import KituraNet

enum ClientError: Swift.Error {
  case errorWithCode(Int)
}

public class Client {
  var service : String
  
  public init(service: String) {
    self.service = service
  } 
//-{% for serviceMethod in renderer.methods %}

  // {{ serviceMethod.description }}
  public func {{ serviceMethod.name }}({{ .|clientParametersDeclaration:serviceMethod }}) throws {{ .|clientReturnDeclaration:serviceMethod }} {
      var path = self.service 
      path = path + "{{ serviceMethod.path }}"
      //-{% for serviceTypeField in serviceMethod|parametersTypeFields %}
      //-{% if serviceTypeField.position == "path" %}
      path = path.replacingOccurrences(of:"{"+"{{ serviceTypeField.name }}"+"}", with:"\({{ serviceTypeField.name }})")
      //-{% endif %}
      //-{% endfor %}
      guard let url = URL(string:path) else {
        throw ClientError.errorWithCode(0)
      }
      var request = URLRequest(url:url)
      request.httpMethod = "{{ serviceMethod.method }}"
      //-{% for serviceTypeField in serviceMethod|parametersTypeFields %}
      //-{% if serviceTypeField.position == "body" %}
      let jsonObject = {{ serviceTypeField.name }}.jsonObject()
      request.httpBody = try JSONSerialization.data(withJSONObject:jsonObject)
      //-{% endif %}
      //-{% endfor %}
      //-{% if serviceMethod|hasResponses %}          
      let (data, response, error) = fetch(request)
      //-{% else %}
      let (_, response, error) = fetch(request)
      //-{% endif %}
      if error != nil {
        throw ClientError.errorWithCode(0)
      }
      guard let httpResponse = response else {
        throw ClientError.errorWithCode(0)
      }
      if httpResponse.statusCode == 200 {
        //-{% if serviceMethod|hasResponses %}    
        if let data = data {
          let jsonObject = try JSONSerialization.jsonObject(with:data)
          if let value = {{ serviceMethod.resultTypeName }}(jsonObject:jsonObject) {          
            return value
          }
        }
        return {{ serviceMethod.resultTypeName }}()
        //-{% endif %}
      } else {
        throw ClientError.errorWithCode(httpResponse.statusCode)
      }
  }
//-{% endfor %}
}

// fetch makes a synchronous request using KituraNet's ClientRequest class
// https://github.com/IBM-Swift/Kitura-net/blob/master/Sources/KituraNet/ClientRequest.swift
public func fetch(_ urlRequest: URLRequest) -> (Data?, HTTPURLResponse?, Error?) {
  var data: Data?
  var urlResponse: HTTPURLResponse?
  let error: Error? = nil // make this mutable when we start using it
  let sem = DispatchSemaphore(value: 0)
  guard let method = urlRequest.httpMethod else {
    return (data, urlResponse, error)
  }
  guard let url = urlRequest.url else {
    return (data, urlResponse, error)
  }
  guard let scheme = url.scheme else {
    return (data, urlResponse, error)
  }
  guard let host = url.host else {
    return (data, urlResponse, error)
  }
  guard let port = url.port else {
    return (data, urlResponse, error)
  }
  let options : [ClientRequest.Options] = [
    .method(method),
    .schema(scheme),
    .hostname(host),
    .port(Int16(port)),
    .path(url.path),
    // headers, etc
  ]
  let request = HTTP.request(options) { (response) in
    guard let response = response else {
      sem.signal()
      return
    }
    var responseData = Data()
    do {
      let code = response.httpStatusCode
      try response.readAllData(into: &responseData)
      data = responseData
      urlResponse = HTTPURLResponse(url:url,
                                    statusCode:code.rawValue,
                                    httpVersion:"HTTP/1.1",
                                    headerFields:[:])
      sem.signal()
      return
    } catch {
      sem.signal()
      return
    }
  }
  if let requestData = urlRequest.httpBody {
    request.write(from:requestData)
  }
  request.end() // send the request
  // now wait on the semaphore for a response
  let result = sem.wait(timeout: DispatchTime.distantFuture)
  switch result {
  case .success:
    return (data, urlResponse, error)
  default: // includes .timeout
    return (data, urlResponse, error)
  }
}
