// Service code

import Kitura
import KituraNet
import Foundation

// A server requires an instance of an implementation of this protocol.
public protocol Service {
//-{% for serviceMethod in renderer.methods %}
  // {{ serviceMethod.description }}
  func {{ serviceMethod.name }} ({{ .|protocolParametersDeclaration:serviceMethod }}) throws {{ .|protocolReturnDeclaration:serviceMethod  }}
//-{% endfor %}
}

func intValue(_ s:String?) -> Int64 {
  return Int64(s!)!
}

public func server(service : Service) -> Router {
  // Create a new router
  let router = Router()

//-{% for serviceMethod in renderer.methods %}
  // {{ serviceMethod.description }}
  router.{{ serviceMethod.method|lowercase }}("{{ serviceMethod|kituraPath }}") { req, res, next in      
      //-{% if serviceMethod|hasParameters %}
      // instantiate the parameters structure
      let parameters = {{ serviceMethod.parametersTypeName }}()
      //-{% for serviceTypeField in serviceMethod|parametersTypeFields %}
      //-{% if serviceTypeField.position == "path" %}
      parameters.{{ serviceTypeField.name }} = intValue(req.parameters["{{ serviceTypeField.name }}"])
      //-{% endif %}
      //-{% endfor %}     
      //-{% if serviceMethod.method == "POST" %}
      // deserialize request from post data
      let bodyString = try req.readString() ?? ""
      let bodyData = bodyString.data(using:.utf8)!
	  var jsonObject : Any? = nil
	  do {
      	jsonObject = try JSONSerialization.jsonObject(with:bodyData)
	  } catch {
		try res.send(status:.badRequest).end()
		return
	  }
      parameters.{{ serviceMethod|bodyParameterFieldName }} = {{ serviceMethod.resultTypeName }}(jsonObject:jsonObject)!
      //-{% endif %}
      //-{% endif %}
      //-{% if serviceMethod|hasParameters %}
      //-{% if serviceMethod|hasResponses %}
      let responses = try! service.{{ serviceMethod.name }}(parameters)
      //-{% else %}
      try! service.{{ serviceMethod.name }}(parameters)
      //-{% endif %}
      //-{% else %}
      //-{% if serviceMethod|hasResponses %}
      let responses = try! service.{{ serviceMethod.name }}()
      //-{% else %}
      try! service.{{ serviceMethod.name }}()
      //-{% endif %}
      //-{% endif %}
      //-{% if serviceMethod|hasResponses %}
        //-{% if serviceMethod|responsesHasFieldNamedOK %}            
        if let ok = responses.ok {
          let jsonObject = ok.jsonObject()
          let responseData = try JSONSerialization.data(withJSONObject:jsonObject)
          let responseString = String(data:responseData, encoding:.utf8)!
          try res.send(responseString).end() 
		  return                          
        } 
        //-{% endif %}
        //-{% if serviceMethod|responsesHasFieldNamedError %}               
        if let errorResponse = responses.error {
          try res.send(status:HTTPStatusCode(rawValue:Int(errorResponse.code))!).end()
		  return               
        }
        //-{% endif %}
        try res.send(status:.internalServerError).end()
      //-{% else %}
      try res.send(status:.OK).end()
      //-{% endif %}
  }

//-{% endfor %}
  return router
}

public func initialize(service: Service, port:Int) {
  // Create a new router
  let router = server(service:service)
  // Add an HTTP server and connect it to the router
  Kitura.addHTTPServer(onPort:port, with: router)
}

public func run() {
  // Start the Kitura runloop (this call never returns)
  Kitura.run()
}
