// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// THIS FILE IS AUTOMATICALLY GENERATED.

package OpenAPIv2

import (
	"fmt"
	"github.com/googleapis/openapi-compiler/helpers"
	"log"
)

func Version() string {
	return "OpenAPIv2"
}

func BuildAdditionalPropertiesItem(in interface{}) *AdditionalPropertiesItem {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildAdditionalPropertiesItem: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	allowedKeys := []string{"boolean", "schema"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &AdditionalPropertiesItem{}
	// bool boolean = 1;
	if helpers.MapHasKey(m, "boolean") {
		x.Boolean = m["boolean"].(bool)
	}
	// Schema schema = 2;
	if helpers.MapHasKey(m, "schema") {
		x.Schema = BuildSchema(m["schema"])
	}
	return x
}

func BuildAny(in interface{}) *Any {
	x := &Any{}
	x.Value = fmt.Sprintf("%+v", in)
	return x
}

func BuildApiKeySecurity(in interface{}) *ApiKeySecurity {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildApiKeySecurity: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"in", "name", "type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"description", "in", "name", "type"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &ApiKeySecurity{}
	// string description = 1;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// string in = 2;
	if helpers.MapHasKey(m, "in") {
		x.In = m["in"].(string)
	}
	// string name = 3;
	if helpers.MapHasKey(m, "name") {
		x.Name = m["name"].(string)
	}
	// string type = 4;
	if helpers.MapHasKey(m, "type") {
		x.Type = m["type"].(string)
	}
	// map<string, Any> vendor_extension = 5;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildBasicAuthenticationSecurity(in interface{}) *BasicAuthenticationSecurity {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildBasicAuthenticationSecurity: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"description", "type"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &BasicAuthenticationSecurity{}
	// string description = 1;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// string type = 2;
	if helpers.MapHasKey(m, "type") {
		x.Type = m["type"].(string)
	}
	// map<string, Any> vendor_extension = 3;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildBodyParameter(in interface{}) *BodyParameter {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildBodyParameter: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"in", "name", "schema"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"description", "in", "name", "required", "schema"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &BodyParameter{}
	// string description = 1;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// string in = 2;
	if helpers.MapHasKey(m, "in") {
		x.In = m["in"].(string)
	}
	// string name = 3;
	if helpers.MapHasKey(m, "name") {
		x.Name = m["name"].(string)
	}
	// bool required = 4;
	if helpers.MapHasKey(m, "required") {
		x.Required = m["required"].(bool)
	}
	// Schema schema = 5;
	if helpers.MapHasKey(m, "schema") {
		x.Schema = BuildSchema(m["schema"])
	}
	// map<string, Any> vendor_extension = 6;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildContact(in interface{}) *Contact {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildContact: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	allowedKeys := []string{"email", "name", "url"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &Contact{}
	// string email = 1;
	if helpers.MapHasKey(m, "email") {
		x.Email = m["email"].(string)
	}
	// string name = 2;
	if helpers.MapHasKey(m, "name") {
		x.Name = m["name"].(string)
	}
	// string url = 3;
	if helpers.MapHasKey(m, "url") {
		x.Url = m["url"].(string)
	}
	// map<string, Any> vendor_extension = 4;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildDefault(in interface{}) *Default {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildDefault: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &Default{}
	// map<string, Any> additional_properties = 1;
	// MAP: Any
	x.AdditionalProperties = make(map[string]*Any, 0)
	for k, v := range m {
		x.AdditionalProperties[k] = BuildAny(v)
	}
	return x
}

func BuildDefinitions(in interface{}) *Definitions {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildDefinitions: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &Definitions{}
	// map<string, Schema> additional_properties = 1;
	// MAP: Schema
	x.AdditionalProperties = make(map[string]*Schema, 0)
	for k, v := range m {
		x.AdditionalProperties[k] = BuildSchema(v)
	}
	return x
}

func BuildDocument(in interface{}) *Document {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildDocument: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"info", "paths", "swagger"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"basePath", "consumes", "definitions", "externalDocs", "host", "info", "parameters", "paths", "produces", "responses", "schemes", "security", "securityDefinitions", "swagger", "tags"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &Document{}
	// string base_path = 1;
	if helpers.MapHasKey(m, "basePath") {
		x.BasePath = m["basePath"].(string)
	}
	// repeated string consumes = 2;
	if helpers.MapHasKey(m, "consumes") {
		v, ok := m["consumes"].([]interface{})
		if ok {
			x.Consumes = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			log.Printf("unexpected: %+v", m["consumes"])
		}
	}
	// Definitions definitions = 3;
	if helpers.MapHasKey(m, "definitions") {
		x.Definitions = BuildDefinitions(m["definitions"])
	}
	// ExternalDocs external_docs = 4;
	if helpers.MapHasKey(m, "externalDocs") {
		x.ExternalDocs = BuildExternalDocs(m["externalDocs"])
	}
	// string host = 5;
	if helpers.MapHasKey(m, "host") {
		x.Host = m["host"].(string)
	}
	// Info info = 6;
	if helpers.MapHasKey(m, "info") {
		x.Info = BuildInfo(m["info"])
	}
	// ParameterDefinitions parameters = 7;
	if helpers.MapHasKey(m, "parameters") {
		x.Parameters = BuildParameterDefinitions(m["parameters"])
	}
	// Paths paths = 8;
	if helpers.MapHasKey(m, "paths") {
		x.Paths = BuildPaths(m["paths"])
	}
	// repeated string produces = 9;
	if helpers.MapHasKey(m, "produces") {
		v, ok := m["produces"].([]interface{})
		if ok {
			x.Produces = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			log.Printf("unexpected: %+v", m["produces"])
		}
	}
	// ResponseDefinitions responses = 10;
	if helpers.MapHasKey(m, "responses") {
		x.Responses = BuildResponseDefinitions(m["responses"])
	}
	// repeated string schemes = 11;
	if helpers.MapHasKey(m, "schemes") {
		v, ok := m["schemes"].([]interface{})
		if ok {
			x.Schemes = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			log.Printf("unexpected: %+v", m["schemes"])
		}
	}
	// repeated SecurityRequirement security = 12;
	if helpers.MapHasKey(m, "security") {
		// repeated class SecurityRequirement
		x.Security = make([]*SecurityRequirement, 0)
		a, ok := m["security"].([]interface{})
		if ok {
			for _, item := range a {
				x.Security = append(x.Security, BuildSecurityRequirement(item))
			}
		}
	}
	// SecurityDefinitions security_definitions = 13;
	if helpers.MapHasKey(m, "securityDefinitions") {
		x.SecurityDefinitions = BuildSecurityDefinitions(m["securityDefinitions"])
	}
	// string swagger = 14;
	if helpers.MapHasKey(m, "swagger") {
		x.Swagger = m["swagger"].(string)
	}
	// repeated Tag tags = 15;
	if helpers.MapHasKey(m, "tags") {
		// repeated class Tag
		x.Tags = make([]*Tag, 0)
		a, ok := m["tags"].([]interface{})
		if ok {
			for _, item := range a {
				x.Tags = append(x.Tags, BuildTag(item))
			}
		}
	}
	return x
}

func BuildExamples(in interface{}) *Examples {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildExamples: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &Examples{}
	// map<string, Any> additional_properties = 1;
	// MAP: Any
	x.AdditionalProperties = make(map[string]*Any, 0)
	for k, v := range m {
		x.AdditionalProperties[k] = BuildAny(v)
	}
	return x
}

func BuildExternalDocs(in interface{}) *ExternalDocs {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildExternalDocs: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"url"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"description", "url"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &ExternalDocs{}
	// string description = 1;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// string url = 2;
	if helpers.MapHasKey(m, "url") {
		x.Url = m["url"].(string)
	}
	// map<string, Any> vendor_extension = 3;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildFileSchema(in interface{}) *FileSchema {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildFileSchema: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"default", "description", "example", "externalDocs", "format", "readOnly", "required", "title", "type"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &FileSchema{}
	// Any default = 1;
	if helpers.MapHasKey(m, "default") {
		x.Default = BuildAny(m["default"])
	}
	// string description = 2;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// Any example = 3;
	if helpers.MapHasKey(m, "example") {
		x.Example = BuildAny(m["example"])
	}
	// ExternalDocs external_docs = 4;
	if helpers.MapHasKey(m, "externalDocs") {
		x.ExternalDocs = BuildExternalDocs(m["externalDocs"])
	}
	// string format = 5;
	if helpers.MapHasKey(m, "format") {
		x.Format = m["format"].(string)
	}
	// bool read_only = 6;
	if helpers.MapHasKey(m, "readOnly") {
		x.ReadOnly = m["readOnly"].(bool)
	}
	// repeated string required = 7;
	if helpers.MapHasKey(m, "required") {
		v, ok := m["required"].([]interface{})
		if ok {
			x.Required = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			log.Printf("unexpected: %+v", m["required"])
		}
	}
	// string title = 8;
	if helpers.MapHasKey(m, "title") {
		x.Title = m["title"].(string)
	}
	// string type = 9;
	if helpers.MapHasKey(m, "type") {
		x.Type = m["type"].(string)
	}
	// map<string, Any> vendor_extension = 10;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildFormDataParameterSubSchema(in interface{}) *FormDataParameterSubSchema {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildFormDataParameterSubSchema: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	allowedKeys := []string{"allowEmptyValue", "collectionFormat", "default", "description", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "in", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "name", "pattern", "required", "type", "uniqueItems"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &FormDataParameterSubSchema{}
	// bool allow_empty_value = 1;
	if helpers.MapHasKey(m, "allowEmptyValue") {
		x.AllowEmptyValue = m["allowEmptyValue"].(bool)
	}
	// string collection_format = 2;
	if helpers.MapHasKey(m, "collectionFormat") {
		x.CollectionFormat = m["collectionFormat"].(string)
	}
	// Any default = 3;
	if helpers.MapHasKey(m, "default") {
		x.Default = BuildAny(m["default"])
	}
	// string description = 4;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// repeated Any enum = 5;
	if helpers.MapHasKey(m, "enum") {
		// repeated class Any
		x.Enum = make([]*Any, 0)
		a, ok := m["enum"].([]interface{})
		if ok {
			for _, item := range a {
				x.Enum = append(x.Enum, BuildAny(item))
			}
		}
	}
	// bool exclusive_maximum = 6;
	if helpers.MapHasKey(m, "exclusiveMaximum") {
		x.ExclusiveMaximum = m["exclusiveMaximum"].(bool)
	}
	// bool exclusive_minimum = 7;
	if helpers.MapHasKey(m, "exclusiveMinimum") {
		x.ExclusiveMinimum = m["exclusiveMinimum"].(bool)
	}
	// string format = 8;
	if helpers.MapHasKey(m, "format") {
		x.Format = m["format"].(string)
	}
	// string in = 9;
	if helpers.MapHasKey(m, "in") {
		x.In = m["in"].(string)
	}
	// PrimitivesItems items = 10;
	if helpers.MapHasKey(m, "items") {
		x.Items = BuildPrimitivesItems(m["items"])
	}
	// int64 max_items = 11;
	if helpers.MapHasKey(m, "maxItems") {
		x.MaxItems = m["maxItems"].(int64)
	}
	// int64 max_length = 12;
	if helpers.MapHasKey(m, "maxLength") {
		x.MaxLength = m["maxLength"].(int64)
	}
	// float maximum = 13;
	if helpers.MapHasKey(m, "maximum") {
		x.Maximum = m["maximum"].(float64)
	}
	// int64 min_items = 14;
	if helpers.MapHasKey(m, "minItems") {
		x.MinItems = m["minItems"].(int64)
	}
	// int64 min_length = 15;
	if helpers.MapHasKey(m, "minLength") {
		x.MinLength = m["minLength"].(int64)
	}
	// float minimum = 16;
	if helpers.MapHasKey(m, "minimum") {
		x.Minimum = m["minimum"].(float64)
	}
	// float multiple_of = 17;
	if helpers.MapHasKey(m, "multipleOf") {
		x.MultipleOf = m["multipleOf"].(float64)
	}
	// string name = 18;
	if helpers.MapHasKey(m, "name") {
		x.Name = m["name"].(string)
	}
	// string pattern = 19;
	if helpers.MapHasKey(m, "pattern") {
		x.Pattern = m["pattern"].(string)
	}
	// bool required = 20;
	if helpers.MapHasKey(m, "required") {
		x.Required = m["required"].(bool)
	}
	// string type = 21;
	if helpers.MapHasKey(m, "type") {
		x.Type = m["type"].(string)
	}
	// bool unique_items = 22;
	if helpers.MapHasKey(m, "uniqueItems") {
		x.UniqueItems = m["uniqueItems"].(bool)
	}
	// map<string, Any> vendor_extension = 23;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildHeader(in interface{}) *Header {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildHeader: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"collectionFormat", "default", "description", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "pattern", "type", "uniqueItems"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &Header{}
	// string collection_format = 1;
	if helpers.MapHasKey(m, "collectionFormat") {
		x.CollectionFormat = m["collectionFormat"].(string)
	}
	// Any default = 2;
	if helpers.MapHasKey(m, "default") {
		x.Default = BuildAny(m["default"])
	}
	// string description = 3;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// repeated Any enum = 4;
	if helpers.MapHasKey(m, "enum") {
		// repeated class Any
		x.Enum = make([]*Any, 0)
		a, ok := m["enum"].([]interface{})
		if ok {
			for _, item := range a {
				x.Enum = append(x.Enum, BuildAny(item))
			}
		}
	}
	// bool exclusive_maximum = 5;
	if helpers.MapHasKey(m, "exclusiveMaximum") {
		x.ExclusiveMaximum = m["exclusiveMaximum"].(bool)
	}
	// bool exclusive_minimum = 6;
	if helpers.MapHasKey(m, "exclusiveMinimum") {
		x.ExclusiveMinimum = m["exclusiveMinimum"].(bool)
	}
	// string format = 7;
	if helpers.MapHasKey(m, "format") {
		x.Format = m["format"].(string)
	}
	// PrimitivesItems items = 8;
	if helpers.MapHasKey(m, "items") {
		x.Items = BuildPrimitivesItems(m["items"])
	}
	// int64 max_items = 9;
	if helpers.MapHasKey(m, "maxItems") {
		x.MaxItems = m["maxItems"].(int64)
	}
	// int64 max_length = 10;
	if helpers.MapHasKey(m, "maxLength") {
		x.MaxLength = m["maxLength"].(int64)
	}
	// float maximum = 11;
	if helpers.MapHasKey(m, "maximum") {
		x.Maximum = m["maximum"].(float64)
	}
	// int64 min_items = 12;
	if helpers.MapHasKey(m, "minItems") {
		x.MinItems = m["minItems"].(int64)
	}
	// int64 min_length = 13;
	if helpers.MapHasKey(m, "minLength") {
		x.MinLength = m["minLength"].(int64)
	}
	// float minimum = 14;
	if helpers.MapHasKey(m, "minimum") {
		x.Minimum = m["minimum"].(float64)
	}
	// float multiple_of = 15;
	if helpers.MapHasKey(m, "multipleOf") {
		x.MultipleOf = m["multipleOf"].(float64)
	}
	// string pattern = 16;
	if helpers.MapHasKey(m, "pattern") {
		x.Pattern = m["pattern"].(string)
	}
	// string type = 17;
	if helpers.MapHasKey(m, "type") {
		x.Type = m["type"].(string)
	}
	// bool unique_items = 18;
	if helpers.MapHasKey(m, "uniqueItems") {
		x.UniqueItems = m["uniqueItems"].(bool)
	}
	// map<string, Any> vendor_extension = 19;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildHeaderParameterSubSchema(in interface{}) *HeaderParameterSubSchema {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildHeaderParameterSubSchema: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	allowedKeys := []string{"collectionFormat", "default", "description", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "in", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "name", "pattern", "required", "type", "uniqueItems"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &HeaderParameterSubSchema{}
	// string collection_format = 1;
	if helpers.MapHasKey(m, "collectionFormat") {
		x.CollectionFormat = m["collectionFormat"].(string)
	}
	// Any default = 2;
	if helpers.MapHasKey(m, "default") {
		x.Default = BuildAny(m["default"])
	}
	// string description = 3;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// repeated Any enum = 4;
	if helpers.MapHasKey(m, "enum") {
		// repeated class Any
		x.Enum = make([]*Any, 0)
		a, ok := m["enum"].([]interface{})
		if ok {
			for _, item := range a {
				x.Enum = append(x.Enum, BuildAny(item))
			}
		}
	}
	// bool exclusive_maximum = 5;
	if helpers.MapHasKey(m, "exclusiveMaximum") {
		x.ExclusiveMaximum = m["exclusiveMaximum"].(bool)
	}
	// bool exclusive_minimum = 6;
	if helpers.MapHasKey(m, "exclusiveMinimum") {
		x.ExclusiveMinimum = m["exclusiveMinimum"].(bool)
	}
	// string format = 7;
	if helpers.MapHasKey(m, "format") {
		x.Format = m["format"].(string)
	}
	// string in = 8;
	if helpers.MapHasKey(m, "in") {
		x.In = m["in"].(string)
	}
	// PrimitivesItems items = 9;
	if helpers.MapHasKey(m, "items") {
		x.Items = BuildPrimitivesItems(m["items"])
	}
	// int64 max_items = 10;
	if helpers.MapHasKey(m, "maxItems") {
		x.MaxItems = m["maxItems"].(int64)
	}
	// int64 max_length = 11;
	if helpers.MapHasKey(m, "maxLength") {
		x.MaxLength = m["maxLength"].(int64)
	}
	// float maximum = 12;
	if helpers.MapHasKey(m, "maximum") {
		x.Maximum = m["maximum"].(float64)
	}
	// int64 min_items = 13;
	if helpers.MapHasKey(m, "minItems") {
		x.MinItems = m["minItems"].(int64)
	}
	// int64 min_length = 14;
	if helpers.MapHasKey(m, "minLength") {
		x.MinLength = m["minLength"].(int64)
	}
	// float minimum = 15;
	if helpers.MapHasKey(m, "minimum") {
		x.Minimum = m["minimum"].(float64)
	}
	// float multiple_of = 16;
	if helpers.MapHasKey(m, "multipleOf") {
		x.MultipleOf = m["multipleOf"].(float64)
	}
	// string name = 17;
	if helpers.MapHasKey(m, "name") {
		x.Name = m["name"].(string)
	}
	// string pattern = 18;
	if helpers.MapHasKey(m, "pattern") {
		x.Pattern = m["pattern"].(string)
	}
	// bool required = 19;
	if helpers.MapHasKey(m, "required") {
		x.Required = m["required"].(bool)
	}
	// string type = 20;
	if helpers.MapHasKey(m, "type") {
		x.Type = m["type"].(string)
	}
	// bool unique_items = 21;
	if helpers.MapHasKey(m, "uniqueItems") {
		x.UniqueItems = m["uniqueItems"].(bool)
	}
	// map<string, Any> vendor_extension = 22;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildHeaders(in interface{}) *Headers {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildHeaders: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &Headers{}
	// map<string, Header> additional_properties = 1;
	// MAP: Header
	x.AdditionalProperties = make(map[string]*Header, 0)
	for k, v := range m {
		x.AdditionalProperties[k] = BuildHeader(v)
	}
	return x
}

func BuildInfo(in interface{}) *Info {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildInfo: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"title", "version"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"contact", "description", "license", "termsOfService", "title", "version"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &Info{}
	// Contact contact = 1;
	if helpers.MapHasKey(m, "contact") {
		x.Contact = BuildContact(m["contact"])
	}
	// string description = 2;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// License license = 3;
	if helpers.MapHasKey(m, "license") {
		x.License = BuildLicense(m["license"])
	}
	// string terms_of_service = 4;
	if helpers.MapHasKey(m, "termsOfService") {
		x.TermsOfService = m["termsOfService"].(string)
	}
	// string title = 5;
	if helpers.MapHasKey(m, "title") {
		x.Title = m["title"].(string)
	}
	// map<string, Any> vendor_extension = 6;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	// string version = 7;
	if helpers.MapHasKey(m, "version") {
		x.Version = m["version"].(string)
	}
	return x
}

func BuildItemsItem(in interface{}) *ItemsItem {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildItemsItem: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	allowedKeys := []string{"schema"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &ItemsItem{}
	// repeated Schema schema = 1;
	if helpers.MapHasKey(m, "schema") {
		// repeated class Schema
		x.Schema = make([]*Schema, 0)
		a, ok := m["schema"].([]interface{})
		if ok {
			for _, item := range a {
				x.Schema = append(x.Schema, BuildSchema(item))
			}
		}
	}
	return x
}

func BuildJsonReference(in interface{}) *JsonReference {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildJsonReference: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"$ref"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"$ref"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &JsonReference{}
	// string _ref = 1;
	if helpers.MapHasKey(m, "$ref") {
		x.XRef = m["$ref"].(string)
	}
	return x
}

func BuildLicense(in interface{}) *License {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildLicense: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"name"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"name", "url"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &License{}
	// string name = 1;
	if helpers.MapHasKey(m, "name") {
		x.Name = m["name"].(string)
	}
	// string url = 2;
	if helpers.MapHasKey(m, "url") {
		x.Url = m["url"].(string)
	}
	// map<string, Any> vendor_extension = 3;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildNonBodyParameter(in interface{}) *NonBodyParameter {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildNonBodyParameter: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"in", "name", "type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	x := &NonBodyParameter{}
	// FormDataParameterSubSchema form_data_parameter_sub_schema = 1;
	{
		t := BuildFormDataParameterSubSchema(m)
		if t != nil {
			x.Oneof = &NonBodyParameter_FormDataParameterSubSchema{FormDataParameterSubSchema: t}
		}
	}
	// HeaderParameterSubSchema header_parameter_sub_schema = 2;
	{
		t := BuildHeaderParameterSubSchema(m)
		if t != nil {
			x.Oneof = &NonBodyParameter_HeaderParameterSubSchema{HeaderParameterSubSchema: t}
		}
	}
	// PathParameterSubSchema path_parameter_sub_schema = 3;
	{
		t := BuildPathParameterSubSchema(m)
		if t != nil {
			x.Oneof = &NonBodyParameter_PathParameterSubSchema{PathParameterSubSchema: t}
		}
	}
	// QueryParameterSubSchema query_parameter_sub_schema = 4;
	{
		t := BuildQueryParameterSubSchema(m)
		if t != nil {
			x.Oneof = &NonBodyParameter_QueryParameterSubSchema{QueryParameterSubSchema: t}
		}
	}
	return x
}

func BuildOauth2AccessCodeSecurity(in interface{}) *Oauth2AccessCodeSecurity {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildOauth2AccessCodeSecurity: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"authorizationUrl", "flow", "tokenUrl", "type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"authorizationUrl", "description", "flow", "scopes", "tokenUrl", "type"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &Oauth2AccessCodeSecurity{}
	// string authorization_url = 1;
	if helpers.MapHasKey(m, "authorizationUrl") {
		x.AuthorizationUrl = m["authorizationUrl"].(string)
	}
	// string description = 2;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// string flow = 3;
	if helpers.MapHasKey(m, "flow") {
		x.Flow = m["flow"].(string)
	}
	// Oauth2Scopes scopes = 4;
	if helpers.MapHasKey(m, "scopes") {
		x.Scopes = BuildOauth2Scopes(m["scopes"])
	}
	// string token_url = 5;
	if helpers.MapHasKey(m, "tokenUrl") {
		x.TokenUrl = m["tokenUrl"].(string)
	}
	// string type = 6;
	if helpers.MapHasKey(m, "type") {
		x.Type = m["type"].(string)
	}
	// map<string, Any> vendor_extension = 7;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildOauth2ApplicationSecurity(in interface{}) *Oauth2ApplicationSecurity {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildOauth2ApplicationSecurity: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"flow", "tokenUrl", "type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"description", "flow", "scopes", "tokenUrl", "type"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &Oauth2ApplicationSecurity{}
	// string description = 1;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// string flow = 2;
	if helpers.MapHasKey(m, "flow") {
		x.Flow = m["flow"].(string)
	}
	// Oauth2Scopes scopes = 3;
	if helpers.MapHasKey(m, "scopes") {
		x.Scopes = BuildOauth2Scopes(m["scopes"])
	}
	// string token_url = 4;
	if helpers.MapHasKey(m, "tokenUrl") {
		x.TokenUrl = m["tokenUrl"].(string)
	}
	// string type = 5;
	if helpers.MapHasKey(m, "type") {
		x.Type = m["type"].(string)
	}
	// map<string, Any> vendor_extension = 6;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildOauth2ImplicitSecurity(in interface{}) *Oauth2ImplicitSecurity {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildOauth2ImplicitSecurity: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"authorizationUrl", "flow", "type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"authorizationUrl", "description", "flow", "scopes", "type"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &Oauth2ImplicitSecurity{}
	// string authorization_url = 1;
	if helpers.MapHasKey(m, "authorizationUrl") {
		x.AuthorizationUrl = m["authorizationUrl"].(string)
	}
	// string description = 2;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// string flow = 3;
	if helpers.MapHasKey(m, "flow") {
		x.Flow = m["flow"].(string)
	}
	// Oauth2Scopes scopes = 4;
	if helpers.MapHasKey(m, "scopes") {
		x.Scopes = BuildOauth2Scopes(m["scopes"])
	}
	// string type = 5;
	if helpers.MapHasKey(m, "type") {
		x.Type = m["type"].(string)
	}
	// map<string, Any> vendor_extension = 6;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildOauth2PasswordSecurity(in interface{}) *Oauth2PasswordSecurity {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildOauth2PasswordSecurity: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"flow", "tokenUrl", "type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"description", "flow", "scopes", "tokenUrl", "type"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &Oauth2PasswordSecurity{}
	// string description = 1;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// string flow = 2;
	if helpers.MapHasKey(m, "flow") {
		x.Flow = m["flow"].(string)
	}
	// Oauth2Scopes scopes = 3;
	if helpers.MapHasKey(m, "scopes") {
		x.Scopes = BuildOauth2Scopes(m["scopes"])
	}
	// string token_url = 4;
	if helpers.MapHasKey(m, "tokenUrl") {
		x.TokenUrl = m["tokenUrl"].(string)
	}
	// string type = 5;
	if helpers.MapHasKey(m, "type") {
		x.Type = m["type"].(string)
	}
	// map<string, Any> vendor_extension = 6;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildOauth2Scopes(in interface{}) *Oauth2Scopes {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildOauth2Scopes: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &Oauth2Scopes{}
	// map<string, string> additional_properties = 1;
	// MAP: string
	x.AdditionalProperties = make(map[string]string, 0)
	for k, v := range m {
		x.AdditionalProperties[k] = v.(string)
	}
	return x
}

func BuildOperation(in interface{}) *Operation {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildOperation: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"responses"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"consumes", "deprecated", "description", "externalDocs", "operationId", "parameters", "produces", "responses", "schemes", "security", "summary", "tags"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &Operation{}
	// repeated string consumes = 1;
	if helpers.MapHasKey(m, "consumes") {
		v, ok := m["consumes"].([]interface{})
		if ok {
			x.Consumes = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			log.Printf("unexpected: %+v", m["consumes"])
		}
	}
	// bool deprecated = 2;
	if helpers.MapHasKey(m, "deprecated") {
		x.Deprecated = m["deprecated"].(bool)
	}
	// string description = 3;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// ExternalDocs external_docs = 4;
	if helpers.MapHasKey(m, "externalDocs") {
		x.ExternalDocs = BuildExternalDocs(m["externalDocs"])
	}
	// string operation_id = 5;
	if helpers.MapHasKey(m, "operationId") {
		x.OperationId = m["operationId"].(string)
	}
	// repeated ParametersItem parameters = 6;
	if helpers.MapHasKey(m, "parameters") {
		// repeated class ParametersItem
		x.Parameters = make([]*ParametersItem, 0)
		a, ok := m["parameters"].([]interface{})
		if ok {
			for _, item := range a {
				x.Parameters = append(x.Parameters, BuildParametersItem(item))
			}
		}
	}
	// repeated string produces = 7;
	if helpers.MapHasKey(m, "produces") {
		v, ok := m["produces"].([]interface{})
		if ok {
			x.Produces = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			log.Printf("unexpected: %+v", m["produces"])
		}
	}
	// Responses responses = 8;
	if helpers.MapHasKey(m, "responses") {
		x.Responses = BuildResponses(m["responses"])
	}
	// repeated string schemes = 9;
	if helpers.MapHasKey(m, "schemes") {
		v, ok := m["schemes"].([]interface{})
		if ok {
			x.Schemes = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			log.Printf("unexpected: %+v", m["schemes"])
		}
	}
	// repeated SecurityRequirement security = 10;
	if helpers.MapHasKey(m, "security") {
		// repeated class SecurityRequirement
		x.Security = make([]*SecurityRequirement, 0)
		a, ok := m["security"].([]interface{})
		if ok {
			for _, item := range a {
				x.Security = append(x.Security, BuildSecurityRequirement(item))
			}
		}
	}
	// string summary = 11;
	if helpers.MapHasKey(m, "summary") {
		x.Summary = m["summary"].(string)
	}
	// repeated string tags = 12;
	if helpers.MapHasKey(m, "tags") {
		v, ok := m["tags"].([]interface{})
		if ok {
			x.Tags = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			log.Printf("unexpected: %+v", m["tags"])
		}
	}
	// map<string, Any> vendor_extension = 13;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildParameter(in interface{}) *Parameter {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildParameter: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &Parameter{}
	// BodyParameter body_parameter = 1;
	{
		t := BuildBodyParameter(m)
		if t != nil {
			x.Oneof = &Parameter_BodyParameter{BodyParameter: t}
		}
	}
	// NonBodyParameter non_body_parameter = 2;
	{
		t := BuildNonBodyParameter(m)
		if t != nil {
			x.Oneof = &Parameter_NonBodyParameter{NonBodyParameter: t}
		}
	}
	return x
}

func BuildParameterDefinitions(in interface{}) *ParameterDefinitions {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildParameterDefinitions: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &ParameterDefinitions{}
	// map<string, Parameter> additional_properties = 1;
	// MAP: Parameter
	x.AdditionalProperties = make(map[string]*Parameter, 0)
	for k, v := range m {
		x.AdditionalProperties[k] = BuildParameter(v)
	}
	return x
}

func BuildParametersItem(in interface{}) *ParametersItem {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildParametersItem: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &ParametersItem{}
	// JsonReference json_reference = 1;
	{
		t := BuildJsonReference(m)
		if t != nil {
			x.Oneof = &ParametersItem_JsonReference{JsonReference: t}
		}
	}
	// Parameter parameter = 2;
	{
		t := BuildParameter(m)
		if t != nil {
			x.Oneof = &ParametersItem_Parameter{Parameter: t}
		}
	}
	return x
}

func BuildPathItem(in interface{}) *PathItem {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildPathItem: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	allowedKeys := []string{"$ref", "delete", "get", "head", "options", "parameters", "patch", "post", "put"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &PathItem{}
	// string _ref = 1;
	if helpers.MapHasKey(m, "$ref") {
		x.XRef = m["$ref"].(string)
	}
	// Operation delete = 2;
	if helpers.MapHasKey(m, "delete") {
		x.Delete = BuildOperation(m["delete"])
	}
	// Operation get = 3;
	if helpers.MapHasKey(m, "get") {
		x.Get = BuildOperation(m["get"])
	}
	// Operation head = 4;
	if helpers.MapHasKey(m, "head") {
		x.Head = BuildOperation(m["head"])
	}
	// Operation options = 5;
	if helpers.MapHasKey(m, "options") {
		x.Options = BuildOperation(m["options"])
	}
	// repeated ParametersItem parameters = 6;
	if helpers.MapHasKey(m, "parameters") {
		// repeated class ParametersItem
		x.Parameters = make([]*ParametersItem, 0)
		a, ok := m["parameters"].([]interface{})
		if ok {
			for _, item := range a {
				x.Parameters = append(x.Parameters, BuildParametersItem(item))
			}
		}
	}
	// Operation patch = 7;
	if helpers.MapHasKey(m, "patch") {
		x.Patch = BuildOperation(m["patch"])
	}
	// Operation post = 8;
	if helpers.MapHasKey(m, "post") {
		x.Post = BuildOperation(m["post"])
	}
	// Operation put = 9;
	if helpers.MapHasKey(m, "put") {
		x.Put = BuildOperation(m["put"])
	}
	// map<string, Any> vendor_extension = 10;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildPathParameterSubSchema(in interface{}) *PathParameterSubSchema {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildPathParameterSubSchema: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"required"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"collectionFormat", "default", "description", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "in", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "name", "pattern", "required", "type", "uniqueItems"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &PathParameterSubSchema{}
	// string collection_format = 1;
	if helpers.MapHasKey(m, "collectionFormat") {
		x.CollectionFormat = m["collectionFormat"].(string)
	}
	// Any default = 2;
	if helpers.MapHasKey(m, "default") {
		x.Default = BuildAny(m["default"])
	}
	// string description = 3;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// repeated Any enum = 4;
	if helpers.MapHasKey(m, "enum") {
		// repeated class Any
		x.Enum = make([]*Any, 0)
		a, ok := m["enum"].([]interface{})
		if ok {
			for _, item := range a {
				x.Enum = append(x.Enum, BuildAny(item))
			}
		}
	}
	// bool exclusive_maximum = 5;
	if helpers.MapHasKey(m, "exclusiveMaximum") {
		x.ExclusiveMaximum = m["exclusiveMaximum"].(bool)
	}
	// bool exclusive_minimum = 6;
	if helpers.MapHasKey(m, "exclusiveMinimum") {
		x.ExclusiveMinimum = m["exclusiveMinimum"].(bool)
	}
	// string format = 7;
	if helpers.MapHasKey(m, "format") {
		x.Format = m["format"].(string)
	}
	// string in = 8;
	if helpers.MapHasKey(m, "in") {
		x.In = m["in"].(string)
	}
	// PrimitivesItems items = 9;
	if helpers.MapHasKey(m, "items") {
		x.Items = BuildPrimitivesItems(m["items"])
	}
	// int64 max_items = 10;
	if helpers.MapHasKey(m, "maxItems") {
		x.MaxItems = m["maxItems"].(int64)
	}
	// int64 max_length = 11;
	if helpers.MapHasKey(m, "maxLength") {
		x.MaxLength = m["maxLength"].(int64)
	}
	// float maximum = 12;
	if helpers.MapHasKey(m, "maximum") {
		x.Maximum = m["maximum"].(float64)
	}
	// int64 min_items = 13;
	if helpers.MapHasKey(m, "minItems") {
		x.MinItems = m["minItems"].(int64)
	}
	// int64 min_length = 14;
	if helpers.MapHasKey(m, "minLength") {
		x.MinLength = m["minLength"].(int64)
	}
	// float minimum = 15;
	if helpers.MapHasKey(m, "minimum") {
		x.Minimum = m["minimum"].(float64)
	}
	// float multiple_of = 16;
	if helpers.MapHasKey(m, "multipleOf") {
		x.MultipleOf = m["multipleOf"].(float64)
	}
	// string name = 17;
	if helpers.MapHasKey(m, "name") {
		x.Name = m["name"].(string)
	}
	// string pattern = 18;
	if helpers.MapHasKey(m, "pattern") {
		x.Pattern = m["pattern"].(string)
	}
	// bool required = 19;
	if helpers.MapHasKey(m, "required") {
		x.Required = m["required"].(bool)
	}
	// string type = 20;
	if helpers.MapHasKey(m, "type") {
		x.Type = m["type"].(string)
	}
	// bool unique_items = 21;
	if helpers.MapHasKey(m, "uniqueItems") {
		x.UniqueItems = m["uniqueItems"].(bool)
	}
	// map<string, Any> vendor_extension = 22;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildPaths(in interface{}) *Paths {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildPaths: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	allowedKeys := []string{}
	allowedPatterns := []string{"^x-", "^/"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &Paths{}
	// map<string, PathItem> path = 1;
	// MAP: PathItem ^/
	x.Path = make(map[string]*PathItem, 0)
	for k, v := range m {
		if helpers.PatternMatches("^/", k) {
			x.Path[k] = BuildPathItem(v)
		}
	}
	// map<string, Any> vendor_extension = 2;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildPrimitivesItems(in interface{}) *PrimitivesItems {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildPrimitivesItems: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	allowedKeys := []string{"collectionFormat", "default", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "pattern", "type", "uniqueItems"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &PrimitivesItems{}
	// string collection_format = 1;
	if helpers.MapHasKey(m, "collectionFormat") {
		x.CollectionFormat = m["collectionFormat"].(string)
	}
	// Any default = 2;
	if helpers.MapHasKey(m, "default") {
		x.Default = BuildAny(m["default"])
	}
	// repeated Any enum = 3;
	if helpers.MapHasKey(m, "enum") {
		// repeated class Any
		x.Enum = make([]*Any, 0)
		a, ok := m["enum"].([]interface{})
		if ok {
			for _, item := range a {
				x.Enum = append(x.Enum, BuildAny(item))
			}
		}
	}
	// bool exclusive_maximum = 4;
	if helpers.MapHasKey(m, "exclusiveMaximum") {
		x.ExclusiveMaximum = m["exclusiveMaximum"].(bool)
	}
	// bool exclusive_minimum = 5;
	if helpers.MapHasKey(m, "exclusiveMinimum") {
		x.ExclusiveMinimum = m["exclusiveMinimum"].(bool)
	}
	// string format = 6;
	if helpers.MapHasKey(m, "format") {
		x.Format = m["format"].(string)
	}
	// PrimitivesItems items = 7;
	if helpers.MapHasKey(m, "items") {
		x.Items = BuildPrimitivesItems(m["items"])
	}
	// int64 max_items = 8;
	if helpers.MapHasKey(m, "maxItems") {
		x.MaxItems = m["maxItems"].(int64)
	}
	// int64 max_length = 9;
	if helpers.MapHasKey(m, "maxLength") {
		x.MaxLength = m["maxLength"].(int64)
	}
	// float maximum = 10;
	if helpers.MapHasKey(m, "maximum") {
		x.Maximum = m["maximum"].(float64)
	}
	// int64 min_items = 11;
	if helpers.MapHasKey(m, "minItems") {
		x.MinItems = m["minItems"].(int64)
	}
	// int64 min_length = 12;
	if helpers.MapHasKey(m, "minLength") {
		x.MinLength = m["minLength"].(int64)
	}
	// float minimum = 13;
	if helpers.MapHasKey(m, "minimum") {
		x.Minimum = m["minimum"].(float64)
	}
	// float multiple_of = 14;
	if helpers.MapHasKey(m, "multipleOf") {
		x.MultipleOf = m["multipleOf"].(float64)
	}
	// string pattern = 15;
	if helpers.MapHasKey(m, "pattern") {
		x.Pattern = m["pattern"].(string)
	}
	// string type = 16;
	if helpers.MapHasKey(m, "type") {
		x.Type = m["type"].(string)
	}
	// bool unique_items = 17;
	if helpers.MapHasKey(m, "uniqueItems") {
		x.UniqueItems = m["uniqueItems"].(bool)
	}
	// map<string, Any> vendor_extension = 18;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildProperties(in interface{}) *Properties {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildProperties: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &Properties{}
	// map<string, Schema> additional_properties = 1;
	// MAP: Schema
	x.AdditionalProperties = make(map[string]*Schema, 0)
	for k, v := range m {
		x.AdditionalProperties[k] = BuildSchema(v)
	}
	return x
}

func BuildQueryParameterSubSchema(in interface{}) *QueryParameterSubSchema {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildQueryParameterSubSchema: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	allowedKeys := []string{"allowEmptyValue", "collectionFormat", "default", "description", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "in", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "name", "pattern", "required", "type", "uniqueItems"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &QueryParameterSubSchema{}
	// bool allow_empty_value = 1;
	if helpers.MapHasKey(m, "allowEmptyValue") {
		x.AllowEmptyValue = m["allowEmptyValue"].(bool)
	}
	// string collection_format = 2;
	if helpers.MapHasKey(m, "collectionFormat") {
		x.CollectionFormat = m["collectionFormat"].(string)
	}
	// Any default = 3;
	if helpers.MapHasKey(m, "default") {
		x.Default = BuildAny(m["default"])
	}
	// string description = 4;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// repeated Any enum = 5;
	if helpers.MapHasKey(m, "enum") {
		// repeated class Any
		x.Enum = make([]*Any, 0)
		a, ok := m["enum"].([]interface{})
		if ok {
			for _, item := range a {
				x.Enum = append(x.Enum, BuildAny(item))
			}
		}
	}
	// bool exclusive_maximum = 6;
	if helpers.MapHasKey(m, "exclusiveMaximum") {
		x.ExclusiveMaximum = m["exclusiveMaximum"].(bool)
	}
	// bool exclusive_minimum = 7;
	if helpers.MapHasKey(m, "exclusiveMinimum") {
		x.ExclusiveMinimum = m["exclusiveMinimum"].(bool)
	}
	// string format = 8;
	if helpers.MapHasKey(m, "format") {
		x.Format = m["format"].(string)
	}
	// string in = 9;
	if helpers.MapHasKey(m, "in") {
		x.In = m["in"].(string)
	}
	// PrimitivesItems items = 10;
	if helpers.MapHasKey(m, "items") {
		x.Items = BuildPrimitivesItems(m["items"])
	}
	// int64 max_items = 11;
	if helpers.MapHasKey(m, "maxItems") {
		x.MaxItems = m["maxItems"].(int64)
	}
	// int64 max_length = 12;
	if helpers.MapHasKey(m, "maxLength") {
		x.MaxLength = m["maxLength"].(int64)
	}
	// float maximum = 13;
	if helpers.MapHasKey(m, "maximum") {
		x.Maximum = m["maximum"].(float64)
	}
	// int64 min_items = 14;
	if helpers.MapHasKey(m, "minItems") {
		x.MinItems = m["minItems"].(int64)
	}
	// int64 min_length = 15;
	if helpers.MapHasKey(m, "minLength") {
		x.MinLength = m["minLength"].(int64)
	}
	// float minimum = 16;
	if helpers.MapHasKey(m, "minimum") {
		x.Minimum = m["minimum"].(float64)
	}
	// float multiple_of = 17;
	if helpers.MapHasKey(m, "multipleOf") {
		x.MultipleOf = m["multipleOf"].(float64)
	}
	// string name = 18;
	if helpers.MapHasKey(m, "name") {
		x.Name = m["name"].(string)
	}
	// string pattern = 19;
	if helpers.MapHasKey(m, "pattern") {
		x.Pattern = m["pattern"].(string)
	}
	// bool required = 20;
	if helpers.MapHasKey(m, "required") {
		x.Required = m["required"].(bool)
	}
	// string type = 21;
	if helpers.MapHasKey(m, "type") {
		x.Type = m["type"].(string)
	}
	// bool unique_items = 22;
	if helpers.MapHasKey(m, "uniqueItems") {
		x.UniqueItems = m["uniqueItems"].(bool)
	}
	// map<string, Any> vendor_extension = 23;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildResponse(in interface{}) *Response {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildResponse: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"description"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"description", "examples", "headers", "schema"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &Response{}
	// string description = 1;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// Examples examples = 2;
	if helpers.MapHasKey(m, "examples") {
		x.Examples = BuildExamples(m["examples"])
	}
	// Headers headers = 3;
	if helpers.MapHasKey(m, "headers") {
		x.Headers = BuildHeaders(m["headers"])
	}
	// SchemaItem schema = 4;
	if helpers.MapHasKey(m, "schema") {
		x.Schema = BuildSchemaItem(m["schema"])
	}
	// map<string, Any> vendor_extension = 5;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildResponseDefinitions(in interface{}) *ResponseDefinitions {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildResponseDefinitions: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &ResponseDefinitions{}
	// map<string, Response> additional_properties = 1;
	// MAP: Response
	x.AdditionalProperties = make(map[string]*Response, 0)
	for k, v := range m {
		x.AdditionalProperties[k] = BuildResponse(v)
	}
	return x
}

func BuildResponseValue(in interface{}) *ResponseValue {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildResponseValue: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &ResponseValue{}
	// JsonReference json_reference = 1;
	{
		t := BuildJsonReference(m)
		if t != nil {
			x.Oneof = &ResponseValue_JsonReference{JsonReference: t}
		}
	}
	// Response response = 2;
	{
		t := BuildResponse(m)
		if t != nil {
			x.Oneof = &ResponseValue_Response{Response: t}
		}
	}
	return x
}

func BuildResponses(in interface{}) *Responses {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildResponses: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	allowedKeys := []string{}
	allowedPatterns := []string{"^([0-9]{3})$|^(default)$", "^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &Responses{}
	// map<string, ResponseValue> response_code = 1;
	// MAP: ResponseValue ^([0-9]{3})$|^(default)$
	x.ResponseCode = make(map[string]*ResponseValue, 0)
	for k, v := range m {
		if helpers.PatternMatches("^([0-9]{3})$|^(default)$", k) {
			x.ResponseCode[k] = BuildResponseValue(v)
		}
	}
	// map<string, Any> vendor_extension = 2;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildSchema(in interface{}) *Schema {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildSchema: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	allowedKeys := []string{"$ref", "additionalProperties", "allOf", "default", "description", "discriminator", "enum", "example", "exclusiveMaximum", "exclusiveMinimum", "externalDocs", "format", "items", "maxItems", "maxLength", "maxProperties", "maximum", "minItems", "minLength", "minProperties", "minimum", "multipleOf", "pattern", "properties", "readOnly", "required", "title", "type", "uniqueItems", "xml"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &Schema{}
	// string _ref = 1;
	if helpers.MapHasKey(m, "$ref") {
		x.XRef = m["$ref"].(string)
	}
	// AdditionalPropertiesItem additional_properties = 2;
	if helpers.MapHasKey(m, "additionalProperties") {
		x.AdditionalProperties = BuildAdditionalPropertiesItem(m["additionalProperties"])
	}
	// repeated Schema all_of = 3;
	if helpers.MapHasKey(m, "allOf") {
		// repeated class Schema
		x.AllOf = make([]*Schema, 0)
		a, ok := m["allOf"].([]interface{})
		if ok {
			for _, item := range a {
				x.AllOf = append(x.AllOf, BuildSchema(item))
			}
		}
	}
	// Any default = 4;
	if helpers.MapHasKey(m, "default") {
		x.Default = BuildAny(m["default"])
	}
	// string description = 5;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// string discriminator = 6;
	if helpers.MapHasKey(m, "discriminator") {
		x.Discriminator = m["discriminator"].(string)
	}
	// repeated Any enum = 7;
	if helpers.MapHasKey(m, "enum") {
		// repeated class Any
		x.Enum = make([]*Any, 0)
		a, ok := m["enum"].([]interface{})
		if ok {
			for _, item := range a {
				x.Enum = append(x.Enum, BuildAny(item))
			}
		}
	}
	// Any example = 8;
	if helpers.MapHasKey(m, "example") {
		x.Example = BuildAny(m["example"])
	}
	// bool exclusive_maximum = 9;
	if helpers.MapHasKey(m, "exclusiveMaximum") {
		x.ExclusiveMaximum = m["exclusiveMaximum"].(bool)
	}
	// bool exclusive_minimum = 10;
	if helpers.MapHasKey(m, "exclusiveMinimum") {
		x.ExclusiveMinimum = m["exclusiveMinimum"].(bool)
	}
	// ExternalDocs external_docs = 11;
	if helpers.MapHasKey(m, "externalDocs") {
		x.ExternalDocs = BuildExternalDocs(m["externalDocs"])
	}
	// string format = 12;
	if helpers.MapHasKey(m, "format") {
		x.Format = m["format"].(string)
	}
	// ItemsItem items = 13;
	if helpers.MapHasKey(m, "items") {
		x.Items = BuildItemsItem(m["items"])
	}
	// int64 max_items = 14;
	if helpers.MapHasKey(m, "maxItems") {
		x.MaxItems = m["maxItems"].(int64)
	}
	// int64 max_length = 15;
	if helpers.MapHasKey(m, "maxLength") {
		x.MaxLength = m["maxLength"].(int64)
	}
	// int64 max_properties = 16;
	if helpers.MapHasKey(m, "maxProperties") {
		x.MaxProperties = m["maxProperties"].(int64)
	}
	// float maximum = 17;
	if helpers.MapHasKey(m, "maximum") {
		x.Maximum = m["maximum"].(float64)
	}
	// int64 min_items = 18;
	if helpers.MapHasKey(m, "minItems") {
		x.MinItems = m["minItems"].(int64)
	}
	// int64 min_length = 19;
	if helpers.MapHasKey(m, "minLength") {
		x.MinLength = m["minLength"].(int64)
	}
	// int64 min_properties = 20;
	if helpers.MapHasKey(m, "minProperties") {
		x.MinProperties = m["minProperties"].(int64)
	}
	// float minimum = 21;
	if helpers.MapHasKey(m, "minimum") {
		x.Minimum = m["minimum"].(float64)
	}
	// float multiple_of = 22;
	if helpers.MapHasKey(m, "multipleOf") {
		x.MultipleOf = m["multipleOf"].(float64)
	}
	// string pattern = 23;
	if helpers.MapHasKey(m, "pattern") {
		x.Pattern = m["pattern"].(string)
	}
	// Properties properties = 24;
	if helpers.MapHasKey(m, "properties") {
		x.Properties = BuildProperties(m["properties"])
	}
	// bool read_only = 25;
	if helpers.MapHasKey(m, "readOnly") {
		x.ReadOnly = m["readOnly"].(bool)
	}
	// repeated string required = 26;
	if helpers.MapHasKey(m, "required") {
		v, ok := m["required"].([]interface{})
		if ok {
			x.Required = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			log.Printf("unexpected: %+v", m["required"])
		}
	}
	// string title = 27;
	if helpers.MapHasKey(m, "title") {
		x.Title = m["title"].(string)
	}
	// TypeItem type = 28;
	if helpers.MapHasKey(m, "type") {
		x.Type = BuildTypeItem(m["type"])
	}
	// bool unique_items = 29;
	if helpers.MapHasKey(m, "uniqueItems") {
		x.UniqueItems = m["uniqueItems"].(bool)
	}
	// map<string, Any> vendor_extension = 30;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	// Xml xml = 31;
	if helpers.MapHasKey(m, "xml") {
		x.Xml = BuildXml(m["xml"])
	}
	return x
}

func BuildSchemaItem(in interface{}) *SchemaItem {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildSchemaItem: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &SchemaItem{}
	// FileSchema file_schema = 1;
	{
		t := BuildFileSchema(m)
		if t != nil {
			x.Oneof = &SchemaItem_FileSchema{FileSchema: t}
		}
	}
	// Schema schema = 2;
	{
		t := BuildSchema(m)
		if t != nil {
			x.Oneof = &SchemaItem_Schema{Schema: t}
		}
	}
	return x
}

func BuildSecurityDefinitions(in interface{}) *SecurityDefinitions {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildSecurityDefinitions: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &SecurityDefinitions{}
	// map<string, SecurityDefinitionsItem> additional_properties = 1;
	// MAP: SecurityDefinitionsItem
	x.AdditionalProperties = make(map[string]*SecurityDefinitionsItem, 0)
	for k, v := range m {
		x.AdditionalProperties[k] = BuildSecurityDefinitionsItem(v)
	}
	return x
}

func BuildSecurityDefinitionsItem(in interface{}) *SecurityDefinitionsItem {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildSecurityDefinitionsItem: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &SecurityDefinitionsItem{}
	// ApiKeySecurity api_key_security = 1;
	{
		t := BuildApiKeySecurity(m)
		if t != nil {
			x.Oneof = &SecurityDefinitionsItem_ApiKeySecurity{ApiKeySecurity: t}
		}
	}
	// BasicAuthenticationSecurity basic_authentication_security = 2;
	{
		t := BuildBasicAuthenticationSecurity(m)
		if t != nil {
			x.Oneof = &SecurityDefinitionsItem_BasicAuthenticationSecurity{BasicAuthenticationSecurity: t}
		}
	}
	// Oauth2AccessCodeSecurity oauth2_access_code_security = 3;
	{
		t := BuildOauth2AccessCodeSecurity(m)
		if t != nil {
			x.Oneof = &SecurityDefinitionsItem_Oauth2AccessCodeSecurity{Oauth2AccessCodeSecurity: t}
		}
	}
	// Oauth2ApplicationSecurity oauth2_application_security = 4;
	{
		t := BuildOauth2ApplicationSecurity(m)
		if t != nil {
			x.Oneof = &SecurityDefinitionsItem_Oauth2ApplicationSecurity{Oauth2ApplicationSecurity: t}
		}
	}
	// Oauth2ImplicitSecurity oauth2_implicit_security = 5;
	{
		t := BuildOauth2ImplicitSecurity(m)
		if t != nil {
			x.Oneof = &SecurityDefinitionsItem_Oauth2ImplicitSecurity{Oauth2ImplicitSecurity: t}
		}
	}
	// Oauth2PasswordSecurity oauth2_password_security = 6;
	{
		t := BuildOauth2PasswordSecurity(m)
		if t != nil {
			x.Oneof = &SecurityDefinitionsItem_Oauth2PasswordSecurity{Oauth2PasswordSecurity: t}
		}
	}
	return x
}

func BuildSecurityRequirement(in interface{}) *SecurityRequirement {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildSecurityRequirement: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &SecurityRequirement{}
	// map<string, StringArray> additional_properties = 1;
	// MAP: StringArray
	x.AdditionalProperties = make(map[string]*StringArray, 0)
	for k, v := range m {
		x.AdditionalProperties[k] = BuildStringArray(v)
	}
	return x
}

func BuildStringArray(in interface{}) *StringArray {
	a, ok := in.([]interface{})
	if ok {
		x := &StringArray{}
		x.Value = make([]string, 0)
		for _, s := range a {
			x.Value = append(x.Value, s.(string))
		}
		return x
	} else {
		return nil
	}
}

func BuildTag(in interface{}) *Tag {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildTag: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	requiredKeys := []string{"name"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil
	}
	allowedKeys := []string{"description", "externalDocs", "name"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &Tag{}
	// string description = 1;
	if helpers.MapHasKey(m, "description") {
		x.Description = m["description"].(string)
	}
	// ExternalDocs external_docs = 2;
	if helpers.MapHasKey(m, "externalDocs") {
		x.ExternalDocs = BuildExternalDocs(m["externalDocs"])
	}
	// string name = 3;
	if helpers.MapHasKey(m, "name") {
		x.Name = m["name"].(string)
	}
	// map<string, Any> vendor_extension = 4;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	return x
}

func BuildTypeItem(in interface{}) *TypeItem {
	value, ok := in.(string)
	x := &TypeItem{}
	if ok {
		x.Value = make([]string, 0)
		x.Value = append(x.Value, value)
	} else {
		log.Printf("unexpected: %!v(MISSING)", in)
	}
	return x
}

func BuildVendorExtension(in interface{}) *VendorExtension {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildVendorExtension: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	x := &VendorExtension{}
	// map<string, Any> additional_properties = 1;
	// MAP: Any
	x.AdditionalProperties = make(map[string]*Any, 0)
	for k, v := range m {
		x.AdditionalProperties[k] = BuildAny(v)
	}
	return x
}

func BuildXml(in interface{}) *Xml {
	m, keys, ok := helpers.UnpackMap(in)
	if !ok {
		log.Printf("unexpected argument to BuildXml: %+v", in)
		log.Printf("%d\n", len(m))
		log.Printf("%+v\n", keys)
		return nil
	}
	allowedKeys := []string{"attribute", "name", "namespace", "prefix", "wrapped"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil
	}
	x := &Xml{}
	// bool attribute = 1;
	if helpers.MapHasKey(m, "attribute") {
		x.Attribute = m["attribute"].(bool)
	}
	// string name = 2;
	if helpers.MapHasKey(m, "name") {
		x.Name = m["name"].(string)
	}
	// string namespace = 3;
	if helpers.MapHasKey(m, "namespace") {
		x.Namespace = m["namespace"].(string)
	}
	// string prefix = 4;
	if helpers.MapHasKey(m, "prefix") {
		x.Prefix = m["prefix"].(string)
	}
	// map<string, Any> vendor_extension = 5;
	// MAP: Any ^x-
	x.VendorExtension = make(map[string]*Any, 0)
	for k, v := range m {
		if helpers.PatternMatches("^x-", k) {
			x.VendorExtension[k] = BuildAny(v)
		}
	}
	// bool wrapped = 6;
	if helpers.MapHasKey(m, "wrapped") {
		x.Wrapped = m["wrapped"].(bool)
	}
	return x
}
